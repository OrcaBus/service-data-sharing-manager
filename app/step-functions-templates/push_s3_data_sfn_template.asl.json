{
  "Comment": "A description of my state machine",
  "QueryLanguage": "JSONata",
  "StartAt": "Set Vars",
  "States": {
    "Set Vars": {
      "Type": "Pass",
      "Next": "Uses JsonL Format",
      "Assign": {
        "pushJobId": "{% $states.input.pushJobId %}",
        "packagingJobId": "{% $states.input.packagingJobId %}",
        "pushLocation": "{% $states.input.pushLocation %}",
        "s3StepsCopyBucket": "${__aws_s3_copy_steps_bucket__}",
        "s3StepsCopyCsvKey": "{% '${__aws_s3_copy_steps_prefix__}' & '${__aws_s3_copy_steps_midfix__}' & $states.context.Execution.Name & '.__index__' & ( ${__use_jsonl_format__} ? '.jsonl' : '.csv') %}"
      }
    },
    "Uses JsonL Format": {
      "Type": "Choice",
      "Choices": [
        {
          "Next": "Query and collect prefixes Count (jsonl)",
          "Condition": "{% /* New S3 Steps copy uses json l */ ${__use_jsonl_format__} %}",
          "Comment": "Use JSONL Format"
        }
      ],
      "Default": "Query and collect prefixes Count"
    },
    "Query and collect prefixes Count (jsonl)": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Output": "{% $states.result.Payload %}",
      "Arguments": {
        "FunctionName": "${__package_file_to_jsonl_data_lambda_function_arn__}",
        "Payload": {
          "packagingJobId": "{% $packagingJobId %}",
          "pushLocation": "{% $pushLocation %}",
          "countOnly": true
        }
      },
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 1,
          "MaxAttempts": 3,
          "BackoffRate": 2,
          "JitterStrategy": "FULL"
        }
      ],
      "Assign": {
        "listCount": "{% $states.result.Payload.listCount %}"
      },
      "Next": "For each destination and source mapping uri (jsonl)"
    },
    "For each destination and source mapping uri (jsonl)": {
      "Type": "Map",
      "Label": "Foreachdestinationandsourcemappingjsonl",
      "MaxConcurrency": 1000,
      "ItemBatcher": {
        "MaxItemsPerBatch": 10,
        "BatchInput": {
          "packagingJobIdMapIter": "{% $packagingJobId %}",
          "pushLocationMapIter": "{% $pushLocation %}",
          "s3StepsCopyBucketMapIter": "{% $s3StepsCopyBucket %}",
          "s3StepsCopyCsvKeyMapIter": "{% $s3StepsCopyCsvKey %}",
          "s3StepsCopyKeyMapIter": "{% $s3StepsCopyCsvKey %}"
        }
      },
      "Items": "{% [$map([0..$listCount-1], function($v, $i, $a) { $i })] %}",
      "ItemProcessor": {
        "ProcessorConfig": {
          "Mode": "DISTRIBUTED",
          "ExecutionType": "STANDARD"
        },
        "StartAt": "Set vars in distributed map (jsonl)",
        "States": {
          "Set vars in distributed map (jsonl)": {
            "Type": "Pass",
            "Next": "For each destination and source mapping list",
            "Assign": {
              "packagingJobIdMapIter": "{% $states.input.BatchInput.packagingJobIdMapIter %}",
              "pushLocationMapIter": "{% $states.input.BatchInput.pushLocationMapIter %}",
              "s3StepsCopyBucketMapIter": "{% $states.input.BatchInput.s3StepsCopyBucketMapIter %}",
              "s3StepsCopyCsvKeyMapIter": "{% $states.input.BatchInput.s3StepsCopyCsvKeyMapIter %}",
              "itemRangeMin": "{% $states.input.Items[0] %}",
              "itemRangeMax": "{% $states.input.Items[-1] %}"
            }
          },
          "For each destination and source mapping list": {
            "Type": "Map",
            "Items": "{% [$map([$itemRangeMin..$itemRangeMax], function($v, $i, $a) { $i })] %}",
            "ItemSelector": {
              "packagingJobIdMapIterX": "{% $packagingJobIdMapIter %}",
              "paginationCountMapIterX": "{% $states.context.Map.Item.Value %}",
              "pushLocationMapIterX": "{% $pushLocationMapIter %}",
              "s3StepsCopyBucketMapIterX": "{% $s3StepsCopyBucketMapIter %}",
              "s3StepsCopyKeyMapIterX": "{% /* https://try.jsonata.org/mZnjTty1- */ $replace($s3StepsCopyCsvKeyMapIter, '__index__', $string($states.context.Map.Item.Index + $itemRangeMin)) %}"
            },
            "ItemProcessor": {
              "ProcessorConfig": {
                "Mode": "INLINE"
              },
              "StartAt": "Set vars in map (jsonl)",
              "States": {
                "Set vars in map (jsonl)": {
                  "Type": "Pass",
                  "Next": "Generate jsonl and upload to s3",
                  "Assign": {
                    "packagingJobIdMapIterX": "{% $states.input.packagingJobIdMapIterX %}",
                    "paginationCountMapIterX": "{% $states.input.paginationCountMapIterX %}",
                    "pushLocationMapIterX": "{% $states.input.pushLocationMapIterX %}",
                    "s3StepsCopyBucketMapIterX": "{% $states.input.s3StepsCopyBucketMapIterX %}",
                    "s3StepsCopyKeyMapIterX": "{% $states.input.s3StepsCopyKeyMapIterX %}"
                  }
                },
                "Generate jsonl and upload to s3": {
                  "Type": "Task",
                  "Resource": "arn:aws:states:::lambda:invoke",
                  "Output": {
                    "destinationBucket": "{% $states.result.Payload.destinationBucket %}",
                    "destinationFolderKey": "{% $states.result.Payload.destinationFolderKey %}"
                  },
                  "Arguments": {
                    "FunctionName": "${__package_file_to_jsonl_data_lambda_function_arn__}",
                    "Payload": {
                      "packagingJobId": "{% $packagingJobIdMapIterX %}",
                      "pushLocation": "{% $pushLocationMapIterX %}",
                      "paginationIndex": "{% $paginationCountMapIterX %}",
                      "s3StepsCopyBucket": "{% $s3StepsCopyBucketMapIterX %}",
                      "s3StepsCopyKey": "{% $s3StepsCopyKeyMapIterX %}"
                    }
                  },
                  "Retry": [
                    {
                      "ErrorEquals": [
                        "Lambda.ServiceException",
                        "Lambda.AWSLambdaException",
                        "Lambda.SdkClientException",
                        "Lambda.TooManyRequestsException"
                      ],
                      "IntervalSeconds": 1,
                      "MaxAttempts": 3,
                      "BackoffRate": 2,
                      "JitterStrategy": "FULL"
                    }
                  ],
                  "Next": "Run S3 Copy"
                },
                "Run S3 Copy": {
                  "Type": "Task",
                  "Resource": "arn:aws:states:::states:startExecution.sync:2",
                  "Arguments": {
                    "StateMachineArn": "${__aws_s3_steps_copy_sfn_arn__}",
                    "Input": {
                      "sourceFilesCsvKey": "{% $substringAfter($s3StepsCopyKeyMapIterX, '${__aws_s3_copy_steps_prefix__}') %}",
                      "destinationBucket": "{% $states.input.destinationBucket %}",
                      "destinationFolderKey": "{% $states.input.destinationFolderKey %}"
                    }
                  },
                  "End": true,
                  "Output": {
                    "stepsExecutionId": "{% $states.result.ExecutionArn %}",
                    "output": "{% $states.result.Output ? $states.result.Output : null %}",
                    "error": "{% $states.result.Error ? $states.result.Error : null %}",
                    "hasError": "{% $states.result.Error ? true : false %}",
                    "errorMessage": "{% $states.result.Cause ? $states.result.Cause : null %}"
                  }
                }
              }
            },
            "End": true
          }
        }
      },
      "Next": "No errors"
    },
    "Query and collect prefixes Count": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Output": {},
      "Arguments": {
        "FunctionName": "${__get_s3_destination_and_source_uri_mappings_lambda_function_arn__}",
        "Payload": {
          "packagingJobId": "{% $packagingJobId %}",
          "pushLocation": "{% $pushLocation %}",
          "countOnly": true
        }
      },
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 1,
          "MaxAttempts": 3,
          "BackoffRate": 2,
          "JitterStrategy": "FULL"
        }
      ],
      "Next": "For each destination and source mapping uri (csv)",
      "Assign": {
        "listCount": "{% $states.result.Payload.listCount %}"
      }
    },
    "For each destination and source mapping uri (csv)": {
      "Type": "Map",
      "Label": "Foreachdestinationandsourcemappingcsv",
      "Items": "{% [$map([0..$listCount], function($v, $i, $a) { $i })] %}",
      "ItemBatcher": {
        "MaxItemsPerBatch": 100,
        "BatchInput": {
          "packagingJobIdMapIter": "{% $packagingJobId %}",
          "pushLocationMapIter": "{% $pushLocation %}",
          "s3StepsCopyBucketMapIter": "{% $s3StepsCopyBucket %}",
          "s3StepsCopyCsvKeyMapIter": "{% $s3StepsCopyCsvKey %}",
          "s3StepsCopyKeyMapIter": "{% $s3StepsCopyCsvKey %}",
          "totalItemCountMapIter": "{% $listCount %}"
        }
      },
      "ItemProcessor": {
        "ProcessorConfig": {
          "Mode": "DISTRIBUTED",
          "ExecutionType": "STANDARD"
        },
        "StartAt": "Set vars in distributed map",
        "States": {
          "Set vars in distributed map": {
            "Type": "Pass",
            "Next": "Query and collect prefixes from Pagination",
            "Assign": {
              "packagingJobIdMapIter": "{% $states.input.BatchInput.packagingJobIdMapIter %}",
              "pushLocationMapIter": "{% $states.input.BatchInput.pushLocationMapIter %}",
              "s3StepsCopyBucketMapIter": "{% $states.input.BatchInput.s3StepsCopyBucketMapIter %}",
              "s3StepsCopyCsvKeyMapIter": "{% $states.input.BatchInput.s3StepsCopyCsvKeyMapIter %}",
              "itemRangeMin": "{% $states.input.Items[0] %}",
              "itemRangeMax": "{% $states.input.Items[-1] %}",
              "totalItemCountMapIter": "{% $states.input.BatchInput.totalItemCountMapIter %}"
            }
          },
          "Query and collect prefixes from Pagination": {
            "Type": "Task",
            "Resource": "arn:aws:states:::lambda:invoke",
            "Output": {
              "destinationAndSourceUriMappingsList": "{% $states.result.Payload.destinationAndSourceUriMappingsList %}"
            },
            "Arguments": {
              "FunctionName": "${__get_s3_destination_and_source_uri_mappings_lambda_function_arn__}",
              "Payload": {
                "packagingJobId": "{% $packagingJobIdMapIter %}",
                "pushLocation": "{% $pushLocationMapIter %}",
                "paginationIndex": ["{% $itemRangeMin %}", "{% $itemRangeMax %}"]
              }
            },
            "Retry": [
              {
                "ErrorEquals": [
                  "Lambda.ServiceException",
                  "Lambda.AWSLambdaException",
                  "Lambda.SdkClientException",
                  "Lambda.TooManyRequestsException"
                ],
                "IntervalSeconds": 1,
                "MaxAttempts": 3,
                "BackoffRate": 2,
                "JitterStrategy": "FULL"
              }
            ],
            "Next": "Map destination and source mapping list"
          },
          "Map destination and source mapping list": {
            "Type": "Map",
            "Items": "{% $states.input.destinationAndSourceUriMappingsList %}",
            "ItemSelector": {
              "destinationUriMapIterX": "{% $states.context.Map.Item.Value.destinationUri %}",
              "sourceUrisListMapIterX": "{% $states.context.Map.Item.Value.sourceUrisList %}",
              "s3StepsCopyBucketMapIterX": "{% $s3StepsCopyBucketMapIter %}",
              "s3StepsCopyKeyMapIterX": "{% /* https://try.jsonata.org/mZnjTty1- */ $replace($s3StepsCopyCsvKeyMapIter, '__index__', $string($states.context.Map.Item.Index + $itemRangeMin)) %}"
            },
            "ItemProcessor": {
              "ProcessorConfig": {
                "Mode": "INLINE"
              },
              "StartAt": "Set vars in map",
              "States": {
                "Set vars in map": {
                  "Type": "Pass",
                  "Assign": {
                    "destinationBucketMapIterX": "{% $replace($states.input.destinationUriMapIterX, /^s3:\\/\\/(.*?)\\/(?:.*)/, \"$1\") %}",
                    "destinationKeyMapIterX": "{% $replace($states.input.destinationUriMapIterX, /^s3:\\/\\/(?:.*?)\\/(.*)/, \"$1\") & '/' %}",
                    "sourceUrisListMapIterX": "{% $states.input.sourceUrisListMapIterX %}",
                    "s3StepsCopyBucketMapIterX": "{% $states.input.s3StepsCopyBucketMapIterX %}",
                    "s3StepsCopyKeyMapIterX": "{% $states.input.s3StepsCopyKeyMapIterX %}"
                  },
                  "Next": "Stagger executions"
                },
                "Stagger executions": {
                  "Type": "Wait",
                  "Seconds": "{% ($random() * $totalItemCountMapIter) ~> $round %}",
                  "Next": "Generate steps function csv and upload to s3"
                },
                "Generate steps function csv and upload to s3": {
                  "Type": "Task",
                  "Resource": "arn:aws:states:::lambda:invoke",
                  "Output": "{% $states.result.Payload %}",
                  "Arguments": {
                    "FunctionName": "${__create_csv_for_s3_steps_copy_lambda_function_arn__}",
                    "Payload": {
                      "sourceUrisList": "{% $sourceUrisListMapIterX %}",
                      "s3StepsCopyBucket": "{% $s3StepsCopyBucketMapIterX %}",
                      "s3StepsCopyKey": "{% $s3StepsCopyKeyMapIterX %}"
                    }
                  },
                  "Retry": [
                    {
                      "ErrorEquals": [
                        "Lambda.ServiceException",
                        "Lambda.AWSLambdaException",
                        "Lambda.SdkClientException",
                        "Lambda.TooManyRequestsException"
                      ],
                      "IntervalSeconds": 1,
                      "MaxAttempts": 3,
                      "BackoffRate": 2,
                      "JitterStrategy": "FULL"
                    }
                  ],
                  "Next": "Run s3 copy"
                },
                "Run s3 copy": {
                  "Type": "Task",
                  "Resource": "arn:aws:states:::states:startExecution.sync:2",
                  "Arguments": {
                    "StateMachineArn": "${__aws_s3_steps_copy_sfn_arn__}",
                    "Input": {
                      "sourceFilesCsvKey": "{% $s3StepsCopyKeyMapIterX %}",
                      "destinationBucket": "{% $destinationBucketMapIterX %}",
                      "destinationPrefixKey": "{% $destinationKeyMapIterX %}",
                      "maxItemsPerBatch": 1
                    }
                  },
                  "Output": {
                    "stepsExecutionId": "{% $states.result.ExecutionArn %}",
                    "output": "{% $states.result.Output ? $states.result.Output : null %}",
                    "error": "{% $states.result.Error ? $states.result.Error : null %}",
                    "hasError": "{% $states.result.Error ? true : false %}",
                    "errorMessage": "{% $states.result.Cause ? $states.result.Cause : null %}"
                  },
                  "End": true
                }
              }
            },
            "End": true,
            "Output": {
              "error": "{% (\n  $appendMessages := function($i, $j){$i & \" \" & $j};\n  $errorMessages := [\n    [ $states.result.(error) ] ~>\n    $filter(function($v, $k){$v != null})\n  ];\n  $errorMessages ? $reduce(\n    $errorMessages,\n    $appendMessages\n  ) : null\n)\n %}",
              "hasError": "{% (\n  [ $states.result.(hasError ? 1 : 0) ] ~>\n  $sum\n) > 0 ? true : false\n %}",
              "errorMessage": "{% (\n  $appendMessages := function($i, $j){$i & \" \" & $j};\n  $errorMessages := [\n    [ $states.result.(errorMessage) ] ~>\n    $filter(function($v, $k){$v != null})\n  ];\n  $errorMessages ? $reduce(\n    $errorMessages,\n    $appendMessages\n  ) : null\n)\n %}"
            }
          }
        }
      },
      "Next": "No errors",
      "Output": {
        "hasError": "{% /* Check if any iterable of hasError is set to true - https://try.jsonata.org/2rVu9vmPA */\n(\n  [\n    $states.result ~>\n    $map(function($resultIter){$resultIter.hasError = true ? 1 : 0})\n  ] ~>\n  $sum\n) > 0 ? true : false %}",
        "errorMessages": "{% /* Check if any iterable of errorMessages exist  -  https://try.jsonata.org/SfgXQTQVr */\n(\n  $appendMessages := function($i, $j){$i & \" \" & $j};\n  $errorMessages := [\n    [ $states.result.(errorMessage) ] ~>\n    $filter(function($v, $k){$v != null})\n  ];\n  $errorMessages ? $reduce(\n    $errorMessages,\n    $appendMessages\n  ) : null\n)\n\n\n\n %}"
      }
    },
    "No errors": {
      "Type": "Choice",
      "Choices": [
        {
          "Next": "Update Fastq Ingest Ids",
          "Condition": "{% $states.input.hasError = false %}",
          "Comment": "No errors"
        }
      ],
      "Default": "Update job database"
    },
    "Update Fastq Ingest Ids": {
      "Type": "Task",
      "Resource": "arn:aws:states:::states:startExecution.sync:2",
      "Arguments": {
        "StateMachineArn": "${__update_fastq_ingest_ids_sfn_arn__}",
        "Input": {
          "pushJobId": "{% $pushJobId %}",
          "packagingJobId": "{% $packagingJobId %}",
          "pushLocation": "{% $pushLocation %}"
        }
      },
      "Next": "Update job database"
    },
    "Update job database": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Output": "{% $states.result.Payload %}",
      "Arguments": {
        "FunctionName": "${__update_push_job_api_lambda_function_arn__}",
        "Payload": {
          "pushJobId": "{% $pushJobId %}",
          "packagingJobId": "{% $packagingJobId %}",
          "hasError": "{% $states.input.hasError ? $states.input.hasError : null %}",
          "errorMessages": "{% $states.input.errorMessages ? $states.input.errorMessages : null %}",
          "status": "{% $states.input.hasError ? 'FAILED' : 'SUCCEEDED' %}"
        }
      },
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 1,
          "MaxAttempts": 3,
          "BackoffRate": 2,
          "JitterStrategy": "FULL"
        }
      ],
      "End": true
    }
  }
}
